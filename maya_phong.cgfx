// Copyright (C) 2012 Simon Otter
// 
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

//
// Loads into Maya using the bundled CGFX Shader Plugin.
// 

// Maya friendly parameters.

// An additive ambient term, set to black for no ambient.
float3 ambient : DIFFUSE
<
	string UIHelp = "Ambient";
> = {0.0, 0.0, 0.0};

float spec_exponent
<
	string UIHelp = "Specular Exponent";
	string UIWidget = "Slider";
	float UIMin = 0.1;
	float UIMax = 250;
> = 1;

texture diffuse_tex
<
	string ResourceType = "2D";
	string UIName =  "Diffuse Texture";
>;

texture normalmap_tex
<
	string ResourceType = "2D";
	string UIName =  "Normal Map Texture";
>;

texture specular_tex
<
	string ResourceType = "2D";
	string UIName =  "Normal Map Texture";
>;

// LIGHT 1

float3 light1_pos : POSITION
<
	string UIHelp = "Light 1 Position";
> = {250, 250, -70};

float3 light1_color : DIFFUSE
<
	string UIName = "Light 1 Colour";
	string UIWidget = "Color";
> = {1.480, 1.470, 1.381};

float3 light2_pos : POSITION
<
	string UIHelp = "Light 2 Position";
> = {160, 0, 670};

float3 light2_color : DIFFUSE
<
	string UIName = "Light 2 Colour";
	string UIWidget = "Color";
> = {0.650, 0.8, 1.25};

// TEXTURES.

sampler2D diffuse_tex_sampler  
<
	string UIName = "Diffuse Map";
> =
	sampler_state 
	{
		Texture = <diffuse_tex>;
		MinFilter = LinearMipMapLinear;
		MagFilter = Linear;
	};

sampler2D normalmap_tex_sampler
<
	string UIName = "Normal Map";
> =
	sampler_state  
	{
		Texture = <normalmap_tex>;
		MinFilter = LinearMipMapLinear;
		MagFilter = Linear;
	};

sampler2D spec_tex_sampler
<
	string UIName = "Specular Map";
> =
	sampler_state  
	{
		Texture = <specular_tex>;
		MinFilter = LinearMipMapLinear;
		MagFilter = Linear;
	};


bool flip_y_normal
<
	string UIHelp = "Flip Y Normal (UDK, CryEngine etc.)";
> = false;

//
// Provided by Maya for viewspace transform.
// object space -> clip space
//
float4x4 WorldViewProjXf : WorldViewProjection;
float4x4 WorldViewProjInverseXf : WorldViewProjectionInverse;
float4x4 WorldViewProjInverseTransposeXf : WorldViewProjectionInverseTranspose;
float4x4 WorldXf : World;
float4x4 WorldInverseXf : WorldInverse;
float4x4 ViewInverseXf : ViewInverse;

float4x4 WorldITXf : WorldInverseTranspose < string UIWidget="none";>;
float4x4 ViewITXf : ViewInverseTranspose < string UIWidget="none";>;

//
// This is Maya's derp structure, it feeds the vertex shader with this.
//
struct appdata
{
	float3 position 	: POSITION;
	float4 normal 		: NORMAL;
	float2 texCoord0 	: TEXCOORD0;
	float3 tangent 		: TEXCOORD1;
	float3 binormal 	: TEXCOORD2;
};

struct vertex_out
{
	// Clip-space.
	float4 position 	: POSITION;
	float2 texCoord0	: TEXCOORD0;
	// These are in object space.
	float3 os_pos;
	float3 camera_dir;
	float3 normal;

	// Transforms object -> tangent space.
	float3x3 tangent_transform;
};

float get_lambert(float3 light_dir, float3 normal)
{
	float l = dot(light_dir, normal);
	return max(l, 0);
}

float3 get_light_dir(float3 pos, float3 l_pos)
{
	return normalize(l_pos - pos);
}

vertex_out vertex_f(appdata IN)
{
	vertex_out OUT;

	OUT.position = mul(WorldViewProjXf, float4(IN.position, 1));
	OUT.os_pos = IN.position.xyz;

	OUT.texCoord0 = IN.texCoord0;
	
	OUT.camera_dir = normalize(mul(WorldViewProjInverseXf, float4(0, 0, 1, 1))).xyz;

	OUT.normal = IN.normal.xyz;
	
	OUT.tangent_transform = 
	float3x3(
		IN.tangent.xyz, 
		flip_y_normal? -IN.binormal.xyz : IN.binormal.xyz, 
		IN.normal.xyz
	);

	return OUT;
}

float3 calculate_light_contrib(float lamb_term, float3 diffuse_map_term, float3 light_color)
{
	return (float3(lamb_term, lamb_term, lamb_term) * light_color.xyz) * diffuse_map_term;
}

float3 calculate_diffuse(float2 lamb_term, float2 texCoord)
{
	// Add the ambient term here, might not be strictly kosher but
	// gives a better looking ambient where the diffuse texture 
	// contributes.
	float3 diffuse_map_term = tex2D(diffuse_tex_sampler, texCoord).xyz;

	// light 1
	float3 light_contrib = calculate_light_contrib(lamb_term.x, diffuse_map_term, light1_color);
	// light 2
	light_contrib += calculate_light_contrib(lamb_term.y, diffuse_map_term, light2_color);

	return light_contrib + (ambient * diffuse_map_term);
}

// Calculates a Phong specular term.
float3 calculate_spec(float3 light_dir, float3 normal, float3 camera_dir, float2 texCoord)
{
	float3 light_reflect = reflect(light_dir, normal);
	// We use max here to remove highlights for surface points pointing away from the light.
	float light_to_camera_ang = max(dot(light_reflect, camera_dir), 0);

	// Technically, the light has a specular term too, but we don't care.
	return pow(light_to_camera_ang, spec_exponent) * tex2D(spec_tex_sampler, texCoord);
}

float4 fragment_f(vertex_out IN) : COLOR 
{
	float3 normal;	
	float3 mapped_normal = 
		lerp(
			float4(-1.0), 
			float4( 1.0), 
			tex2D(normalmap_tex_sampler, IN.texCoord0));

	float3 light1_dir_tspace = mul(IN.tangent_transform, get_light_dir(IN.os_pos, light1_pos));
	float3 light2_dir_tspace = mul(IN.tangent_transform, get_light_dir(IN.os_pos, light2_pos));

	float3 camera_dir_tspace = mul(IN.tangent_transform, IN.camera_dir);
	
	if (mapped_normal.x == 1.0 && mapped_normal.y == 1.0 && mapped_normal.z == 1.0) 
	// mostly true if no nmap assigned.
	{
		normal = mul(IN.tangent_transform, IN.normal);
	}
	else
	{
		normal = mapped_normal.xyz;
	}

	float3 diff_term = calculate_diffuse(
		float2(
			get_lambert(
				light1_dir_tspace, 
				normal),
			get_lambert(
				light2_dir_tspace, 
				normal)
		),
		IN.texCoord0);

	float3 spec_term = calculate_spec(light1_dir_tspace, normal, camera_dir_tspace, IN.texCoord0);
	
	return saturate(float4(diff_term + spec_term, 1)); 
}

technique main {
	pass p0 {
		VertexProgram = compile gp4vp vertex_f();
		DepthTestEnable = true;
		DepthMask = true;
		CullFaceEnable = false;
		FragmentProgram = compile gp4fp fragment_f();
	}
}
