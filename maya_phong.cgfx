//
// By SIMON OTTER 2012.
// Loads into Maya using the bundled CGFX Shader Plugin.
// 

// Maya friendly parameters.

// An additive ambient term, set to black for no ambient.
float3 ambient : DIFFUSE
<
	string UIHelp = "Ambient";
> = {0.0, 0.0, 0.0};

float spec_exponent
<
	string UIHelp = "Specular Exponent";
	string UIWidget = "Slider";
	float UIMin = 0.1;
	float UIMax = 250;
> = 1;

texture diffuse_tex
<
	string ResourceType = "2D";
	string UIName =  "Diffuse Texture";
>;

texture normalmap_tex
<
	string ResourceType = "2D";
	string UIName =  "Normal Map Texture";
>;

float3 light_pos : POSITION
<
	string UIHelp = "Light Position";
> = {0, 1, 0};

sampler2D diffuse_tex_sampler = sampler_state 
{
	Texture = <diffuse_tex>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

sampler2D normalmap_tex_sampler = sampler_state 
{
	Texture = <normalmap_tex>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

//
// Provided by Maya for viewspace transform.
// object space -> clip space
//
float4x4 WorldViewProjXf : WorldViewProjection;
float4x4 WorldViewProjInverseXf : WorldViewProjectionInverse;
float4x4 WorldViewProjInverseTransposeXf : WorldViewProjectionInverseTranspose;
float4x4 WorldXf : World;
float4x4 WorldInverseXf : WorldInverse;
float4x4 ViewInverseXf : ViewInverse;

float4x4 WorldITXf : WorldInverseTranspose < string UIWidget="none";>;
float4x4 ViewITXf : ViewInverseTranspose < string UIWidget="none";>;

//
// This is Maya's derp structure, it feeds the vertex shader with this.
//
struct appdata
{
	float3 position 	: POSITION;
	float4 normal 		: NORMAL;
	float2 texCoord0 	: TEXCOORD0;
	float3 tangent 		: TEXCOORD1;
	float3 binormal 	: TEXCOORD2;
};

struct vertex_out
{
	// Clip-space.
	float4 position 	: POSITION;
	float2 texCoord0	: TEXCOORD0;
	// These are in object space.
	float3 os_pos;
	float3 camera_dir;
	float3 normal;
};

float get_lambert(float3 light_dir, float3 normal)
{
	float l = dot(light_dir, normal);
	return max(l, 0);
}

float3 get_light_dir(float3 pos, float3 l_pos)
{
	return normalize(l_pos - pos);
}

vertex_out vertex_f(appdata IN)
{
	vertex_out OUT;

	OUT.position = mul(WorldViewProjXf, float4(IN.position, 1));
	OUT.os_pos = IN.position.xyz;

	OUT.texCoord0 = IN.texCoord0;
	
	OUT.camera_dir = normalize(mul(WorldViewProjInverseXf, float4(0, 0, 1, 1))).xyz;

	OUT.normal = IN.normal.xyz;
	
	return OUT;
}

float3 calculate_diffuse(float lamb_term, float2 texCoord)
{
	// Add the ambient term here, might not be strictly kosher but
	// gives a better looking ambient where the diffuse texture 
	// contributes.
	float3 diffuse_coef = float3(lamb_term, lamb_term, lamb_term) + ambient;
	return diffuse_coef * tex2D(diffuse_tex_sampler, texCoord).xyz;
}

// Calculates a Phong specular term.
float3 calculate_spec(float3 light_dir, float3 normal, float3 camera_dir)
{
	float3 light_reflect = reflect(light_dir, normal);
	// We use max here to remove highlights for surface points pointing away from the light.
	float light_to_camera_ang = max(dot(light_reflect, camera_dir), 0);

	// Light has no specular component yet, or colour.
	float3 light_spec = float3(1, 1, 1);
	return pow(light_to_camera_ang, spec_exponent) * light_spec;
}

float4 fragment_f(vertex_out IN) : COLOR 
{
	float3 normal = IN.normal;
	// Not used yet, will be used for normal mapping.
	float3 mapped_normal = tex2D(normalmap_tex_sampler, IN.texCoord0);

	float3 light_dir = get_light_dir(IN.os_pos, light_pos);

	float3 diff_term = calculate_diffuse(
		get_lambert(
			light_dir, 
			normal), 
		IN.texCoord0);

	float3 spec_term = calculate_spec(light_dir, normal, IN.camera_dir);
	
	return saturate(float4(ambient + diff_term + spec_term, 1)); 
}

technique main {
	pass p0 {
		VertexProgram = compile gp4vp vertex_f();
		DepthTestEnable = true;
		DepthMask = true;
		CullFaceEnable = false;
		FragmentProgram = compile gp4fp fragment_f();
	}
}
