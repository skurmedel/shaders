#version 400

/*
    Emulate a bad CRT screen with an aperture grille or shadow mask.
*/

glsl 
{
    #include "../glsl/gamma_correct.glsl"
    #include "snoise.glsl"
    #include "../glsl/cie.glsl"
    #include "../glsl/luminosity.glsl"
}

#line 10016
animation buffer_in = sequence("../testimgs/pulp/pulp*.png", 25) : filter(bilinear), full_range(true), repeat(true);

/*
    The uniform holding the current time elapsed as a float. It can wrap around
    after a couple of seconds without problems.
*/
#define CRT_TIME_UNIFORM        shadron_Time
/*
    How many horizontal lines we have per screen height.
*/
#define CRT_SCANLINES           480
/*
    The "radius" of the electron beam, this value is usually not meaningful to
    change.
*/
#define CRT_PROJECTION_RADIUS   1
/*
    How far the colour channels are allowed to separate in pixels.
*/
#define CRT_WORST_CONVERGENCE   8.0
/*
    Scales the impurity distance from center factor.
*/
#define CRT_IMPURITY_CENTER_DISTANCE_SCALE  12.0
/*
    The magnitude of the ripple for the tracking error effect.

    Increase to get more wobbly "VHS"/"bad antenna" look.
*/
#define CRT_TRACKING_ERROR_SCALE     0.025 

/*
    How much "afterimage". This is scaled by the previous frame luminosity at 
    each pixel: the idea is it more strongly affects highlights where the "beam" 
    has higher energy and the phosphor emits for longer.
*/
parameter float ghosting            = 0.8 : range(0, 1);

parameter float ghosting_blur       = 5 : range(0, 10);

/*
    The distance of the projected screen, this affects the screen warping and
    bending. Set at 1 for a straight image.
*/
parameter float screen_dist         = 0.9 : range(0, 2);
/*
    Scales the projected screen in XY for greater control.
*/
parameter vec2  proj_scale          = vec2(0.9) : range(vec2(-2), vec2(2));
/*
    How strong luminosity noise to add.
*/
parameter float noise_scale         = 0.015 : range(0, 1);
/*
    How well the three colour channels converge. A value of 1 means perfectly.

    The shader always have perfect "static convergence", meaning they always 
    converge in the center of the image.
*/
parameter float convergence         = 0.45 : range(0, 1);
/*
    Simulates some electrons for a given colour hitting the phosphor for another
    colour, e.g, some of the red beam hits some green phosphors which produces
    incorrect colours.
*/
parameter float impurity            = 0.75 : range(0, 2);

glsl vec3 crt_ghost(sampler2D self, vec2 pos, float dt)
{
    /*
        Some tracking errors (the beam being inconsistent between scans), not 
        very realistic but adds subtle plausible look, it also makes it look a
        bit like bad antenna reception or a shitty VHS. It helps sell the 
        look.
    */
    float tracking_error = CRT_TRACKING_ERROR_SCALE * snoise(pos.yy * 16) * snoise(pos.yy + vec2(7 * CRT_TIME_UNIFORM));
    
    /*
        Our input is sRGB, so lets linearize it (remove the gamma correction),
        first.
    */
    vec3 rgb = srgb_gamma_linearize(texture(buffer_in, pos - vec2(0.1) * tracking_error).rgb);

    /*
        Calculate the luminosity and scale it between 7 and 10.
    */
    float luminosity = srgb_luminosity(rgb);

    rgb = mix(rgb, vec3(luminosity), tracking_error * 20);

    vec3 noise = vec3((1.0 - luminosity) * noise_scale * snoise(pos.xy * 256) * snoise(pos.yy + vec2(2 * CRT_TIME_UNIFORM)));

    /*
        Apply some ghosting here. It easier here because we still have access to 
        the luminosity information and can use it to control the ghosting.
    */
    vec3 prev = pow(texture(self, pos, ghosting_blur).rgb, vec3(1.2));
    rgb += clamp(ghosting * (0.7 + luminosity * 0.3) * prev, 0.0, 1.0) + noise;
    
    return rgb;
}

feedback buffer_ghost = glsl(crt_ghost, sizeof(buffer_in)): full_range(true), hidden(true), map(clamp), filter(trilinear);

glsl vec4 crt_final_image(vec2 pos)
{
    vec2 img_sz = sizeof(buffer_in);
    float aspect = img_sz.y/img_sz.x;
    
    /*
        Calculate the position on the CRT tube screen by projecting each pixel 
        pos onto it.
    */
    vec3 screen_pos = vec3(proj_scale * vec2(1, aspect) * (pos-vec2(0.5, 0.5)), screen_dist);
    float hypotenuse = length(screen_pos);

    float sin_screen = screen_pos.y / hypotenuse;
    float cos_screen = screen_pos.x / hypotenuse;
    vec2 offsets = vec2(cos_screen, sin_screen) * vec2(CRT_PROJECTION_RADIUS - hypotenuse);

    vec2 projected_pos = vec2(pos.x, pos.y) - offsets;

    float scanline = abs(cos(pos.y * CRT_SCANLINES * 3.1417/2));

    /*
        Sample three times, one for each colour channel and offset by convergence.
    */
    vec3 green_sample = texture(buffer_ghost, projected_pos).rgb;
    vec3 red_sample = texture(buffer_ghost, projected_pos * (1 + CRT_WORST_CONVERGENCE/img_sz.x * (1.0 - convergence))).rgb;
    vec3 blue_sample = texture(buffer_ghost, projected_pos * (1 - CRT_WORST_CONVERGENCE/img_sz.x * (1.0 - convergence))).rgb;

    float r = red_sample.r;
    float g = green_sample.g;
    float b = blue_sample.b;
    
    /*
        Impurity calculations, where we muddle together the channels a bit to 
        fake CRT impurity.
    */
    float impurity_scale = (screen_pos.x * screen_pos.x + screen_pos.y * screen_pos.y) * CRT_IMPURITY_CENTER_DISTANCE_SCALE;
    mat3 impurity_mat = mat3(
        0.7,    0.0,    0.2,
        0.3,    0.6,    0.1,
        0.2,    0.2,    0.4
    );

    vec3 impure = mix(vec3(r,g,b), impurity_mat * vec3(r,g,b), impurity_scale * impurity) * 1.4;
      
    vec3 wet = scanline * impure;


    return vec4(
        srgb_gamma_correct(wet), 
          smoothstep(1.005, 1.0, projected_pos.x) * smoothstep(1.005, 1.0, 1.0-projected_pos.x) 
        * smoothstep(1.005, 1.0, projected_pos.y) * smoothstep(1.005, 1.0, 1.0-projected_pos.y));
}

animation buffer_out = glsl(crt_final_image, sizeof(buffer_ghost));

//export png_sequence(buffer_out, "D:\\Code\\Repos\\shaders\\testimgs\\awsdwrf\\pulp-lol?.png", 25, 4.8);
