#version 400

/*
    Emulate a bad CRT screen with an aperture grille or shadow mask.
*/

glsl 
{
    #include "../glsl/gamma_correct.glsl"
    #include "snoise.glsl"
}

#line 1012
animation buffer_in = sequence("../testimgs/pulp/pulp*.png", 25) : filter(bilinear);

/*
    How many horizontal lines we have per screen height.
*/
#define CRT_SCANLINES           480
/*
    The "radius" of the electron beam, this value is usually not meaningful to
    change.
*/
#define CRT_PROJECTION_RADIUS   1

/*
    How much to blur the UV channels in the YUV processing step.

    This uses mipmapping for cheapo blur, so the quality and steps depend on 
    the settings for the textures.
*/
parameter float uv_blur     = 4   : range(0, 5);
/*
    How much to blur the Y channel in the YUV processing step.

    This uses mipmapping for cheapo blur, so the quality and steps depend on 
    the settings for the textures.
*/
parameter float luma_blur   = 1   : range(0, 5);
/*
    How much "afterimage". This is scaled by the previous frame luminosity at 
    each pixel: the idea is it more strongly affects highlights where the "beam" 
    has higher energy and the phosphor emits for longer.
*/
parameter float ghosting    = 0.8 : range(0, 1);
/*
    A standard black level lift.
*/
parameter float lift        = 0.005 : range(0, 1);
/*
    The distance of the projected screen, this affects the screen warping and
    bending. Set at 1 for a straight image.
*/
parameter float screen_dist = 0.9 : range(0, 2);
/*
    Scales the projected screen in XY for greater control.
*/
parameter vec2  proj_scale   = vec2(0.9) : range(vec2(-2), vec2(2));
/*
    How strong luma noise to add.
*/
parameter float noise_scale = 0.02 : range(0, 1);

/*
    Converts the input to Y'UV.
*/
glsl vec4 crt_yuv(sampler2D self, vec2 pos, float dt)
{
    /* 
        Emulate 4:2:2 chroma subsampling by only repeating every even pixel in 
        the horizontal.
    */
    vec2 img_sz = sizeof(buffer_in);
    vec2 pixel_sz = 1.0/img_sz;
    /*
        Changing the moduli here gives a more pronounced effect but for large 
        values it will look horrible.
    */
    int idx = -int(pos.x * img_sz.x) % 2;

    /*
        Some tracking errors (the beam being inconsistent between scans), not 
        very realistic but adds subtle plausible look.
    */
    float tracking_error = 0.015 * snoise(pos.yy * 16) * snoise(pos.yy + vec2(7 * shadron_Time));

    /*
        Our input is sRGB, so lets linearize it (remove the gamma correction),
        first.
    */
    vec3 rgb = srgb_gamma_linearize(texture(buffer_in, pos + idx * vec2(pixel_sz.x, 0) - vec2(0.1) * tracking_error).rgb);

    /*
        Rec601 luma weights. 
        Todo: We should use the ones from luma.glsl.
    */
    vec4 yuv = vec4(1);
    yuv.x = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;
    yuv.y = 0.436 * (rgb.b - yuv.x)/(1.0 - 0.114);
    yuv.z = 0.615 * (rgb.r - yuv.x)/(1.0 - 0.299);
    /*
        Apply lift to luma.
    */
    yuv.x = max(lift, yuv.x);

    /*
        Apply some ghosting here. It easier here because we still have access to 
        the luminosity information and can use it to control the ghosting.
    */
    vec4 prev = texture(self, pos, 2);

    return yuv + prev * clamp(ghosting * prev.x, 0.0, 0.7); 
}

feedback buffer_yuv = glsl(crt_yuv, sizeof(buffer_in)): full_range(true), hidden(true), filter(trilinear), map(mirror);

glsl vec3 crt_chroma_blur(sampler2D self, vec2 pos, float dt)
{
    /*
        Blur the chromaticity a bit.
    */
    vec3 blur_uv = texture(buffer_yuv, pos, uv_blur).rgb;
    vec3 yuv = vec3(texture(buffer_yuv, pos, luma_blur).r, blur_uv.g, blur_uv.b);

    /*
        Add some luma noise.
    */
    float noise = snoise(200 * pos + 239 * shadron_Time);
    noise *= noise * noise * noise_scale;
    yuv.x += noise * (1.0-yuv.x);

    /*
        We go back to linear sRGB from Y'UV.
    */
    vec3 new = vec3(
        yuv.x + 1.14 * yuv.z,
        yuv.x - 0.395 * yuv.y - 0.581 * yuv.z,
        yuv.x + 2.033 * yuv.y
    );
    
    return new;
}

feedback buffer_chroma_blur = glsl(crt_chroma_blur, sizeof(buffer_yuv)): full_range(true), hidden(true), map(clamp), synchronize(buffer_yuv);

glsl vec4 crt_final_image(vec2 pos)
{
    vec2 img_sz = sizeof(buffer_in);
    float aspect = img_sz.y/img_sz.x;
    
    /*
        Calculate the position on the CRT tube screen by projecting each pixel 
        pos onto it.
    */
    vec3 screen_pos = vec3(proj_scale * vec2(1, aspect) * (pos-vec2(0.5, 0.5)), screen_dist);
    float hypotenuse = length(screen_pos);

    float sin_screen = screen_pos.y / hypotenuse;
    float cos_screen = screen_pos.x / hypotenuse;
    vec2 offsets = vec2(cos_screen, sin_screen) * vec2(CRT_PROJECTION_RADIUS - hypotenuse);

    vec2 projected_pos = vec2(pos.x, pos.y) - offsets;

    

    float scanline = abs(cos(pos.y * CRT_SCANLINES * 3.1417/2));

    /*
        We can now sample the other buffers and compose the final image.
    */

    vec3 dry = texture(buffer_in, pos).rgb;
    vec3 wet =  scanline * texture(buffer_chroma_blur, projected_pos).rgb * 1.4;

    return vec4(
        mix(srgb_gamma_correct(wet), dry, pos.x >1 ), 
          smoothstep(1.005, 1.0, projected_pos.x) * smoothstep(1.005, 1.0, 1.0-projected_pos.x) 
        * smoothstep(1.005, 1.0, projected_pos.y) * smoothstep(1.005, 1.0, 1.0-projected_pos.y));
}

animation buffer_out = glsl(crt_final_image, sizeof(buffer_chroma_blur));

export png_sequence(buffer_out, "D:\\Code\\Repos\\shaders\\testimgs\\awsdwrf\\pulp-lol?.png", 25, 4.8);
