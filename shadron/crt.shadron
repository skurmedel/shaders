#version 400

/*
    Emulate a bad CRT screen with an aperture grille or shadow mask.
*/

glsl 
{
    #include "../glsl/gamma_correct.glsl"
}

#line 1012
animation buffer_in = sequence("../testimgs/pulp/pulp*.png", 25) : filter(bilinear);

#define CRT_SCANLINES           480
#define CRT_PROJECTION_RADIUS   1

parameter float uv_blur     = 4   : range(0, 5);
parameter float luma_blur   = 1   : range(0, 5);
parameter float ghosting    = 0.8 : range(0, 1);
parameter float lift        = 0.005 : range(0, 1);
parameter float screen_dist = 0.9 : range(0, 2);
parameter vec2  proj_scale   = vec2(0.9) : range(vec2(-2), vec2(2));
parameter float noise_scale = 0.015 : range(0, 1);

glsl
{
    //
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
// 

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v)
  {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
// First corner
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

// Other corners
  vec2 i1;
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
  //i1.y = 1.0 - i1.x;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  // x0 = x0 - 0.0 + 0.0 * C.xx ;
  // x1 = x0 - i1 + 1.0 * C.xx ;
  // x2 = x0 - 1.0 + 2.0 * C.xx ;
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

// Permutations
  i = mod289(i); // Avoid truncation effects in permutation
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
		+ i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

// Gradients: 41 points uniformly over a line, mapped onto a diamond.
// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

// Normalise gradients implicitly by scaling m
// Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

// Compute final noise value at P
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}
}

/*
    Converts the input to Y'UV.
*/
glsl vec4 crt_yuv(sampler2D self, vec2 pos, float dt)
{
    /* 
        Emulate 4:2:2 chroma subsampling by only repeating every even pixel in 
        the horizontal.
    */
    vec2 img_sz = sizeof(buffer_in);
    vec2 pixel_sz = 1.0/img_sz;
    int idx = -int(pos.x * img_sz.x) % 2;

    /*
        Our input is sRGB, so lets linearize it (remove the gamma correction),
        first.
    */
    vec3 rgb = srgb_gamma_linearize(texture(buffer_in, pos + idx * vec2(pixel_sz.x, 0)).rgb);

    /*
        Rec601 luma weights. 
        Todo: We should use the ones from luma.glsl.
    */
    vec4 yuv = vec4(1);
    yuv.x = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;
    yuv.y = 0.436 * (rgb.b - yuv.x)/(1.0 - 0.114);
    yuv.z = 0.615 * (rgb.r - yuv.x)/(1.0 - 0.299);
    /*
        Apply lift to luma.
    */
    yuv.x = max(lift, yuv.x);

    /*
        Apply some ghosting here. It easier here because we still have access to 
        the luminosity information and can use it to control the ghosting.
    */
    vec4 prev = texture(self, pos, 2);

    return yuv + prev * clamp(ghosting * prev.x, 0.0, 0.7); 
}

feedback buffer_yuv = glsl(crt_yuv, sizeof(buffer_in)): full_range(true), hidden(true), filter(trilinear), map(mirror);

glsl vec3 crt_chroma_blur(sampler2D self, vec2 pos, float dt)
{
    /*
        Blur the chromaticity a bit.
    */
    vec3 blur_uv = texture(buffer_yuv, pos, uv_blur).rgb;
    vec3 yuv = vec3(texture(buffer_yuv, pos, luma_blur).r, blur_uv.g, blur_uv.b);

    /*
        Add some luma noise.
    */
    float noise = snoise(200 * pos + 239 * shadron_Time);
    noise *= noise * noise * noise_scale;
    yuv.x += noise * (1.0-yuv.x);

    /*
        We go back to linear sRGB from Y'UV.
    */
    vec3 new = vec3(
        yuv.x + 1.14 * yuv.z,
        yuv.x - 0.395 * yuv.y - 0.581 * yuv.z,
        yuv.x + 2.033 * yuv.y
    );
    
    return new;
}

feedback buffer_chroma_blur = glsl(crt_chroma_blur, sizeof(buffer_yuv)): full_range(true), hidden(true), map(clamp), synchronize(buffer_yuv);

glsl vec4 crt_final_image(vec2 pos)
{
    vec2 img_sz = sizeof(buffer_in);
    float aspect = img_sz.y/img_sz.x;
    
    /*
        Calculate the position on the CRT tube screen by projecting each pixel 
        pos onto it.
    */
    vec3 screen_pos = vec3(proj_scale * vec2(1, aspect) * (pos-vec2(0.5, 0.5)), screen_dist);
    float hypotenuse = length(screen_pos);

    float sin_screen = screen_pos.y / hypotenuse;
    float cos_screen = screen_pos.x / hypotenuse;
    vec2 offsets = vec2(cos_screen, sin_screen) * vec2(CRT_PROJECTION_RADIUS - hypotenuse);

    vec2 projected_pos = vec2(pos.x, pos.y) - offsets;

    /*
        Some tracking errors.
    */
    float tracking_error = 0.015 * snoise(pos.yy * 16) * snoise(pos.yy + vec2(7 * shadron_Time));

    float scanline = abs(cos(pos.y * CRT_SCANLINES * 3.1417));

    /*
        We can now sample the other buffers and compose the final image.
    */

    vec3 dry = texture(buffer_in, pos).rgb;
    vec3 wet =  scanline * texture(buffer_chroma_blur, projected_pos - vec2(0.1) * tracking_error).rgb * 1.4;

    return vec4(
        mix(srgb_gamma_correct(wet), dry, pos.x >1 ), 
          smoothstep(1.005, 1.0, projected_pos.x) * smoothstep(1.005, 1.0, 1.0-projected_pos.x) 
        * smoothstep(1.005, 1.0, projected_pos.y) * smoothstep(1.005, 1.0, 1.0-projected_pos.y));
}

animation buffer_out = glsl(crt_final_image, sizeof(buffer_chroma_blur));

export png_sequence(buffer_out, "D:\\Code\\Repos\\shaders\\testimgs\\awsdwrf\\pulp-lol?.png", 25, 4.8);
